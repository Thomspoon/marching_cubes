// Based off of code from http://paulbourke.net/geometry/polygonise/

#version 450 core

int corner_index_a_from_edge[12] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    0,
    1,
    2,
    3
};

int corner_index_b_from_edge[12] = {
    1,
    2,
    3,
    0,
    5,
    6,
    7,
    4,
    4,
    5,
    6,
    7
};

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

struct Triangle {
    vec3 vertex_a;
    vec3 vertex_b;
    vec3 vertex_c;
};

layout (std430, binding = 0) buffer Pos
{
    vec4[2][2][2] points;
};

layout (std430, binding = 1) buffer TriangleBuffer
{
    Triangle[] triangles;
};

layout (std430, binding = 2) buffer Triangulation
{
    int triangulation[256][16];
};

layout (std430, binding = 3) buffer Edges
{
    float edges[100];
};

layout(binding = 0) uniform atomic_uint num_triangles;
uniform int axis_length;
uniform float iso_level;

vec3 vertex_interpolate(vec4 p1, vec4 p2)
{
   float mu = (iso_level - p1.w) / (p2.w - p1.w);

   return p1.xyz + mu * (p2.xyz - p1.xyz);
}

int index_from_coord(int x, int y, int z) {
    return x * axis_length * axis_length + y * axis_length + z;
}

void main()
{
    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);

    // Stop one point before the end because voxel includes neighbouring points
    if (gid.x >= axis_length-1 || gid.y >= axis_length-1 || gid.z >= axis_length-1) {
        return;
    }

    // 8 corners of the current cube
    vec4 cube_corners[8] = {
        vec4(0.0, 0.0, 0.0, 0.41),// points[gid.x    ][gid.y    ][gid.z    ],
        vec4(1.0, 0.0, 0.0, 1.82),// points[gid.x + 1][gid.y    ][gid.z    ],
        vec4(1.0, 0.0, 1.0, 1.41),// points[gid.x + 1][gid.y    ][gid.z + 1],
        vec4(0.0, 0.0, 1.0, 1.38),// points[gid.x    ][gid.y    ][gid.z + 1],
        vec4(0.0, 1.0, 0.0, 1.82),// points[gid.x    ][gid.y + 1][gid.z    ],
        vec4(1.0, 1.0, 0.0, 1.77),// points[gid.x + 1][gid.y + 1][gid.z    ],
        vec4(1.0, 1.0, 1.0, 0.35),// points[gid.x + 1][gid.y + 1][gid.z + 1],
        vec4(0.0, 1.0, 1.0, 1.41),// points[gid.x    ][gid.y + 1][gid.z + 1]
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    int cube_index = 0;
    if (cube_corners[0].w < iso_level) cube_index |= 1;
    if (cube_corners[1].w < iso_level) cube_index |= 2;
    if (cube_corners[2].w < iso_level) cube_index |= 4;
    if (cube_corners[3].w < iso_level) cube_index |= 8;
    if (cube_corners[4].w < iso_level) cube_index |= 16;
    if (cube_corners[5].w < iso_level) cube_index |= 32;
    if (cube_corners[6].w < iso_level) cube_index |= 64;
    if (cube_corners[7].w < iso_level) cube_index |= 128;

    // Return early if cube is not visible
    if(cube_index == 0 || cube_index == 255) {
        return;
    }

    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cube_index][i] != -1; i +=3) {
        int a0 = corner_index_a_from_edge[triangulation[cube_index][i]];
        int b0 = corner_index_b_from_edge[triangulation[cube_index][i]];

        int a1 = corner_index_a_from_edge[triangulation[cube_index][i+1]];
        int b1 = corner_index_b_from_edge[triangulation[cube_index][i+1]];

        int a2 = corner_index_a_from_edge[triangulation[cube_index][i+2]];
        int b2 = corner_index_b_from_edge[triangulation[cube_index][i+2]];

        // edges[i] = cube_corners[a0].x;
        // edges[i+1] = cube_corners[a0].y;
        // edges[i+2] = cube_corners[a0].z;

        // edges[i+3] = cube_corners[b0].x;
        // edges[i+4] = cube_corners[b0].y;
        // edges[i+5] = cube_corners[b0].z;

        // edges[i+6] = cube_corners[a1].x;
        // edges[i+7] = cube_corners[a1].y;
        // edges[i+8] = cube_corners[a1].z;

        // edges[i+9] = cube_corners[b1].x;
        // edges[i+10] = cube_corners[b1].y;
        // edges[i+11] = cube_corners[b1].z;

        // edges[i+12] = cube_corners[a2].x;
        // edges[i+13] = cube_corners[a2].y;
        // edges[i+14] = cube_corners[a2].z;

        // edges[i+15] = cube_corners[b2].x;
        // edges[i+16] = cube_corners[b2].y;
        // edges[i+17] = cube_corners[b2].z;

        Triangle tri;
        tri.vertex_a = vec3(float(cube_corners[a0].x + cube_corners[b0].x)/2.0f, float(cube_corners[a0].y + cube_corners[b0].y)/2.0f, float(cube_corners[a0].z + cube_corners[b0].z)/2.0f);//vertex_interpolate(cube_corners[a0], cube_corners[b0]);
        tri.vertex_b = vec3(float(cube_corners[a1].x + cube_corners[b1].x)/2.0f, float(cube_corners[a1].y + cube_corners[b1].y)/2.0f, float(cube_corners[a1].z + cube_corners[b1].z)/2.0f);//vertex_interpolate(cube_corners[a1], cube_corners[b1]);
        tri.vertex_c = vec3(float(cube_corners[a2].x + cube_corners[b2].x)/2.0f, float(cube_corners[a2].y + cube_corners[b2].y)/2.0f, float(cube_corners[a2].z + cube_corners[b2].z)/2.0f);//vertex_interpolate(cube_corners[a2], cube_corners[b2]);

        triangles[atomicCounter(num_triangles)] = tri;

        atomicCounterIncrement(num_triangles);

        memoryBarrier();
    }
}