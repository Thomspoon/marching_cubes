// Based off of code from http://paulbourke.net/geometry/polygonise/

#version 450 core

int corner_index_a_from_edge[12] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    0,
    1,
    2,
    3
};

int corner_index_b_from_edge[12] = {
    1,
    2,
    3,
    0,
    5,
    6,
    7,
    4,
    4,
    5,
    6,
    7
};

layout(local_size_x=1, local_size_y=1, local_size_z=1) in;

struct Triangle {
    vec4 vertex_a;
    vec4 vertex_b;
    vec4 vertex_c;
};

layout (std430, binding = 0) buffer Pos
{
    vec4[16][16][16] points;
};

layout (std430, binding = 1) buffer TriangleBuffer
{
    Triangle[] triangles;
};

layout (std430, binding = 2) buffer Triangulation
{
    int triangulation[256][16];
};

layout (std430, binding = 3) buffer Scratch
{
    float scratch[1000];
};

layout(binding = 0) uniform atomic_uint num_triangles;
uniform int axis_length;
uniform float iso_level;

vec3 vertex_interpolate(vec4 p1, vec4 p2)
{
   float mu = (iso_level - p1.w) / (p2.w - p1.w);

   return p1.xyz + mu * (p2.xyz - p1.xyz);
}

int index_from_coord(int x, int y, int z) {
    return x * axis_length * axis_length + y * axis_length + z;
}

void main()
{
    ivec3 gid = ivec3(gl_GlobalInvocationID.xyz);

    // Stop one point before the end because voxel includes neighbouring points
    if (gid.x >= axis_length-1 || gid.y >= axis_length-1 || gid.z >= axis_length-1) {
        return;
    }

    // 8 corners of the current cube
    vec4 cube_corners[8] = {
        points[gid.x    ][gid.y    ][gid.z    ],
        points[gid.x + 1][gid.y    ][gid.z    ],
        points[gid.x + 1][gid.y    ][gid.z + 1],
        points[gid.x    ][gid.y    ][gid.z + 1],
        points[gid.x    ][gid.y + 1][gid.z    ],
        points[gid.x + 1][gid.y + 1][gid.z    ],
        points[gid.x + 1][gid.y + 1][gid.z + 1],
        points[gid.x    ][gid.y + 1][gid.z + 1]
    };

    // Calculate unique index for each cube configuration.
    // There are 256 possible values
    // A value of 0 means cube is entirely inside surface; 255 entirely outside.
    int cube_index = 0;
    if (cube_corners[0].w < iso_level) cube_index |= 1;
    if (cube_corners[1].w < iso_level) cube_index |= 2;
    if (cube_corners[2].w < iso_level) cube_index |= 4;
    if (cube_corners[3].w < iso_level) cube_index |= 8;
    if (cube_corners[4].w < iso_level) cube_index |= 16;
    if (cube_corners[5].w < iso_level) cube_index |= 32;
    if (cube_corners[6].w < iso_level) cube_index |= 64;
    if (cube_corners[7].w < iso_level) cube_index |= 128;

    // Return early if cube is not visible
    if(cube_index == 0 || cube_index == 255) {
        return;
    }

    // Create triangles for current cube configuration
    for (int i = 0; triangulation[cube_index][i] != -1; i +=3) {
        int a0 = corner_index_a_from_edge[triangulation[cube_index][i]];
        int b0 = corner_index_b_from_edge[triangulation[cube_index][i]];

        int a1 = corner_index_a_from_edge[triangulation[cube_index][i+1]];
        int b1 = corner_index_b_from_edge[triangulation[cube_index][i+1]];

        int a2 = corner_index_a_from_edge[triangulation[cube_index][i+2]];
        int b2 = corner_index_b_from_edge[triangulation[cube_index][i+2]];

        Triangle tri;

        // No interpolation
        // tri.vertex_a = vec4(float(cube_corners[a0].x + cube_corners[b0].x)/2.0f, float(cube_corners[a0].y + cube_corners[b0].y)/2.0f, float(cube_corners[a0].z + cube_corners[b0].z)/2.0f, 0.0f);//vertex_interpolate(cube_corners[a0], cube_corners[b0]);
        // tri.vertex_b = vec4(float(cube_corners[a1].x + cube_corners[b1].x)/2.0f, float(cube_corners[a1].y + cube_corners[b1].y)/2.0f, float(cube_corners[a1].z + cube_corners[b1].z)/2.0f, 0.0f);//vertex_interpolate(cube_corners[a1], cube_corners[b1]);
        // tri.vertex_c = vec4(float(cube_corners[a2].x + cube_corners[b2].x)/2.0f, float(cube_corners[a2].y + cube_corners[b2].y)/2.0f, float(cube_corners[a2].z + cube_corners[b2].z)/2.0f, 0.0f);//vertex_interpolate(cube_corners[a2], cube_corners[b2]);

        tri.vertex_a = vec4(vertex_interpolate(cube_corners[a0], cube_corners[b0]), 0.0f);
        tri.vertex_b = vec4(vertex_interpolate(cube_corners[a1], cube_corners[b1]), 0.0f);
        tri.vertex_c = vec4(vertex_interpolate(cube_corners[a2], cube_corners[b2]), 0.0f);

        int index = index_from_coord(gid.x, gid.y, gid.z) * 9;
        scratch[index] = tri.vertex_a.x;
        scratch[index+1] = tri.vertex_a.y;
        scratch[index+2] = tri.vertex_a.z;

        scratch[index+3] = tri.vertex_b.x;
        scratch[index+4] = tri.vertex_b.y;
        scratch[index+5] = tri.vertex_b.z;

        scratch[index+6] = tri.vertex_c.x;
        scratch[index+7] = tri.vertex_c.y;
        scratch[index+8] = tri.vertex_c.z;

        triangles[atomicCounterIncrement(num_triangles)] = tri;

        memoryBarrier();
    }
}